<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-15">
    <title>vcio2 API Reference</title>
    <meta content="Marcel Müller" name="author">
    <link rel="stylesheet" href="infstyle.css" type="text/css">
  </head>
  <body>
    <h1>vcio2 API Reference</h1>
    <p><a class="nobr" href="index.html">&#9650; Top</a>, <a class="nobr" href="#IOCTL">&#9660; vcio2 IOCTLs</a>, <a class="nobr" href="#mmap">&#9660;
        Memory mapping</a>, <a class="nobr" href="guide.html">&#9654; Programming guide</a></p>
    <h2>Access vcio2 device</h2>
    <h3><a id="open" name="open"></a>open device</h3>
    <pre>int vcio2 = open("/dev/vcio2", O_RDWR);</pre>
    <p>Open the vcio2 device for further usage.</p>
    <p>Note that all resources acquired by this device are tied to this device handle. So do not close it unless you no longer need
      the resources.</p>
    <p>Device handles of vcio2 cannot be reasonably inherited nor passed to forked process instances. The resources are always tied
      to the PID that opened the device.</p>
    <p>All calls to vcio2 handles are <em>thread-safe</em>.</p>
    <h3>close device</h3>
    <pre>close(vcio2);</pre>
    <p>Close the vcio2 device and release all resources.</p>
    <h2><a id="IOCTL" name="IOCTL"></a>vcio2 IOCTLs</h2>
    <h3><tt><a name="IOCTL_GET_VCIO_VERSION" id="IOCTL_GET_VCIO_VERSION"></a>IOCTL_GET_VCIO_VERSION (0x800465C0)</tt></h3>
    <p>Return the vcio2 API version. The high word is the major version, the low word the minor version. Currently <tt>0x00000002</tt>,
      i.e. 0.2.</p>
    <pre>uint32_t version;<br>int retval = ioctl(vcio2, IOCTL_GET_VCIO_VERSION, &amp;version);</pre>
    <h3><tt><a id="IOCTL_MEM_ALLOC" name="IOCTL_MEM_ALLOC"></a>IOCTL_MEM_ALLOCATE (0xC00C6501)</tt></h3>
    <p>Allocate GPU memory. The memory is continuous in physical address and taken from the reserved GPU memory pool.</p>
    <pre>typedef struct
{ union {
    struct
    { unsigned int size;
      unsigned int alignment;
      unsigned int flags;<br>    } in;
    struct
    { unsigned int handle;
    } out;
  };
} vcio_mem_allocate;<br><br>vcio_mem_allocate buf;<br>...<br>int retval = ioctl(vcio2, IOCTL_MEM_ALLOCATE, &amp;buf);</pre>
    <dl>
      <dt><tt>in.size</tt></dt>
      <dd>Number of bytes to allocate.<br>
        Note that with CMA enabled (dynamic GPU memory size) in <tt>/boot/config.txt</tt> allocations of more than 16 MiB seem to
        fail.</dd>
      <dt><tt>in.alignment</tt></dt>
      <dd>Alignment of the resulting buffer in physical memory.</dd>
      <dt><tt>in.flags</tt></dt>
      <dd><tt>0xC</tt> &#8658; cached; <tt>0x4</tt> &#8658; direct<br>
        Other flags unknown. The parameter is directly passed to the <tt>VCMSG_SET_ALLOCATE_MEM</tt> mailbox message.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> &#8658; success; any other value &#8658; error. See <tt>errno</tt>.</dd>
      <dt><tt>out.handle</tt></dt>
      <dd>Memory handle. To be used with <a href="#IOCTL_MEM_LOCK"><tt>IOCTL_MEM_LOCK</tt></a>.</dd>
    </dl>
    <p>vcio2 keeps track of the allocated memory chunks. As soon as the vcio2 device is closed or the application terminates. The
      memory is given back to the GPU memory pool. So remember to keep the device open!</p>
    <h3><tt><a id="IOCTL_MEM_RELEASE" name="IOCTL_MEM_RELEASE"></a>IOCTL_MEM_RELEASE (0x00006502)</tt></h3>
    <pre>int retval = ioctl(vcio2, IOCTL_MEM_RELEASE, handle);</pre>
    <p>Release GPU memory. This also unlocks the memory segment if still locked.</p>
    <dl>
      <dt><tt>handle</tt></dt>
      <dd>Memory handle from <a href="#IOCTL_MEM_ALLOC"><tt>IOCTL_MEM_ALLOC</tt></a>.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> &#8658; success; any other value &#8658; error. See <tt>errno</tt>.</dd>
    </dl>
    <h3><tt><a id="IOCTL_MEM_LOCK" name="IOCTL_MEM_LOCK"></a>IOCTL_MEM_LOCK (0xC0046503)</tt></h3>
    <pre>int addr = handle;<br>int retval = ioctl(vcio2, IOCTL_MEM_LOCK, &amp;addr);</pre>
    <p>Lock the memory segment at a physical address.</p>
    <dl>
      <dt><tt>handle</tt></dt>
      <dd>Memory handle from <a href="#IOCTL_MEM_ALLOC"><tt>IOCTL_MEM_ALLOC</tt></a>.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> &#8658; success; any other value &#8658; error. See <tt>errno</tt>.</dd>
      <dt><tt>addr</tt></dt>
      <dd>Physical memory address where the memory segment has been locked.</dd>
    </dl>
    <h3><tt><a id="IOCTL_MEM_UNLOCK" name="IOCTL_MEM_UNLOCK"></a>IOCTL_MEM_UNLOCK (0x00006504) </tt></h3>
    <pre>int retval = ioctl(vcio2, IOCTL_MEM_UNLOCK, handle);
</pre>
    <p>Unlock memory segment and release the binding to a physical address.</p>
    <dl>
      <dt><tt>handle</tt></dt>
      <dd>Memory handle from <a href="#IOCTL_MEM_ALLOC"><tt>IOCTL_MEM_ALLOC</tt></a>.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> &#8658; success; any other value = error. See <tt>errno</tt>.</dd>
    </dl>
    <h3><tt><a id="IOCTL_ENABLE_QPU" name="IOCTL_EXEC_QPU"></a>IOCTL_ENABLE_QPU (0x00006512)</tt></h3>
    <p>Power on/off the GPU.</p>
    <pre>int retval = ioctl(vcio2, IOCTL_ENABLE_GPU, flag);</pre>
    <dl>
      <dt><tt>flag</tt></dt>
      <dd><tt>1</tt> &#8658; power on the QPU; <tt>0</tt> &#8658; power off the QPU<br>
        Note that the QPU may not really be powered off because another open handle to the vcio2 device might still request QPU
        power. Only when the last open instance of vcio2 committed the power off the QPU is actually turned off.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> &#8658; success; any other value &#8658; error. See <tt>errno</tt>.</dd>
    </dl>
    <p>The QPU is automatically powered on at <tt>IOCTL_EXEC_QPU</tt> and automatically turned off when the last process closes the
      vcio2 device. So there is normally no need to call this IOCTL explicitly.</p>
    <h3><tt><a id="IOCTL_EXEC_QPU" name="IOCTL_EXEC_QPU"></a>IOCTL_EXEC_QPU (0x40106511)</tt></h3>
    <p>Execute QPU code.</p>
    <pre>typedef struct
{ unsigned int uniforms;
  unsigned int code;
} vcio_exec_qpu_entry;<br>typedef struct
{ struct
  { unsigned int num_qpus;
    unsigned int control;
    unsigned int noflush;
    unsigned int timeout;
  } in;
} vcio_exec_qpu;<br><br>vcio_exec_qpu buf;<br>...<br>int retval = ioctl(vcio2, IOCTL_EXEC_QPU, &amp;buf);</pre>
    <dl>
      <dt><tt>num_qpus</tt></dt>
      <dd>Number of QPUs that should be kicked off. Each QPU receives their own shader code and their own set of uniforms. So this
        is also the size of the <tt>control</tt> array.</dd>
      <dt><tt>control</tt></dt>
      <dd>Setup entries for each QPU containing the physical start address of the uniforms and the code. This is a <i>physical</i>
        pointer to an array of <tt>vcio_qpu_entry</tt> structures with exactly <tt>num_qpus</tt> elements.</dd>
      <dt><tt>noflush</tt></dt>
      <dd>Flag: do not flush the cache before starting the QPU code.</dd>
      <dt><tt>timeout</tt></dt>
      <dd>Timeout in milliseconds to wait for an host interrupt. If the timeout elapses the function returns with an error. Note
        that this will not stop the QPU code so far.</dd>
      <dt>return value</dt>
      <dd><tt>0</tt> in case of success; non-zero otherwise, see <tt>errno</tt>. You will get <tt>EACCES</tt> when one of the
        physical memory pointers do not belong to a locked memory segment allocated by the same device handle.</dd>
    </dl>
    <p>Although vcio2 does some basic checks to prevent accidental access to invalid memory <em>it cannot check for memory access
        done by the QPU code</em>. So you have to take care to execute only valid QPU code, otherwise the Raspberry might crash.
      However, in most cases the Raspi will recover from faults after the timeout and no resources will be lost. So GPU development
      is significantly relaxed.</p>
    <p>While QPU code is executing the Raspi kernel can no longer access the the property channel used for several other purposes,
      e.g. power management or several firmware calls. Every attempt to do such a function is blocked until the QPU code raises an
      host interrupt or the timeout elapsed. This is a restriction of the firmware rather than vcio2.</p>
    <p>If the QPU is not yet powered on, the power will be turned on automatically before this request. The power will not be turned
      off afterwards unless the device is closed or you explicitly request it by <tt><a href="#IOCTL_ENABLE_QPU">IOCTL_ENABLE_QPU</a>
        0</tt> and of course no other process needs QPU power.</p>
    <dl>
    </dl>
    <h3><tt><a name="IOCTL_SET_V3D_PERF_COUNT" id="IOCTL_SET_V3D_PERF_COUNT"></a>IOCTL_SET_V3D_PERF_COUNT (0x000065c1)</tt></h3>
    <p>Enable or disable V3D performance counters for this instance.</p>
    <pre>int retval = ioctl(vcio2, enabled);</pre>
    <dl>
      <dt><tt>enabled</tt></dt>
      <dd>Bit vector of performance counters to activate. Any combination of</dd>
      <dd>
        <pre>V3D_PERF_COUNT_QPU_CYCLES_IDLE<br>V3D_PERF_COUNT_QPU_CYCLES_VERTEX_SHADING<br>V3D_PERF_COUNT_QPU_CYCLES_FRAGMENT_SHADING<br>V3D_PERF_COUNT_QPU_CYCLES_VALID_INSTRUCTIONS<br>V3D_PERF_COUNT_QPU_CYCLES_STALLED_TMU<br>V3D_PERF_COUNT_QPU_CYCLES_STALLED_SCOREBOARD<br>V3D_PERF_COUNT_QPU_CYCLES_STALLED_VARYINGS<br>V3D_PERF_COUNT_QPU_INSTRUCTION_CACHE_HITS<br>V3D_PERF_COUNT_QPU_INSTRUCTION_CACHE_MISSES<br>V3D_PERF_COUNT_QPU_UNIFORMS_CACHE_HITS<br>V3D_PERF_COUNT_QPU_UNIFORMS_CACHE_MISSES<br>V3D_PERF_COUNT_TMU_TEXTURE_QUADS_PROCESSED<br>V3D_PERF_COUNT_TMU_TEXTURE_CACHE_MISSES<br>V3D_PERF_COUNT_VPM_CYCLES_STALLED_VDW<br>V3D_PERF_COUNT_VPM_CYCLES_STALLED_VCD<br>V3D_PERF_COUNT_L2C_L2_CACHE_HITS<br>V3D_PERF_COUNT_L2C_L2_CACHE_MISSES</pre>
      </dd>
    </dl>
    <p>Performance counters are a limited resource of VideoCore IV. <em>No more than 16 counters can be activated at the same time.</em><br>
      Furthermore vcio2 currently does not support switching enabled counters for individual QPU executions of different open driver
      instances. I.e. no more than 16 counters can be activated at the same time over all vcio2 users. However, if two instances
      request the same counter it will be physically shared. But every instance has it's own set of counter values. They are only
      activated when an execution of the own instance is performed. In fact this makes the counter <tt>V3D_PERF_COUNT_QPU_CYCLES_IDLE</tt>
      somewhat useless since it will not count the time between executions.</p>
    <h3><tt><a name="IOCTL_GET_V3D_PERF_COUNTIOCTL_GET_V3D_PERF_COUNT" id="IOCTL_GET_V3D_PERF_COUNTIOCTL_GET_V3D_PERF_COUNT"></a>IOCTL_GET_V3D_PERF_COUNT
        (0x800465c1)</tt></h3>
    <p>Get currently activated performance counters of this instance.</p>
    <pre>uint32_t enabled;<br>int retval = ioctl(vcio2, IOCTL_GET_V3D_PERF_COUNT, &amp;enabled);</pre>
    <h3><tt><a name="IOCTL_READ_V3D_PERF_COUNT" id="IOCTL_READ_V3D_PERF_COUNT"></a>IOCTL_READ_V3D_PERF_COUNT (0x804065c2)</tt></h3>
    <p>Read all enabled performance counters.</p>
    <pre>uint32_t counters[16];<br>int retval = ioctl(vcio2, IOCTL_GET_V3D_PERF_COUNT, &amp;counters);</pre>
    <p>The counter values are returned in ascending order and disabled counters will not have an empty slot. E.g. if you enabled <tt>V3D_PERF_COUNT_QPU_INSTRUCTION_CACHE_HITS|V3D_PERF_COUNT_L2C_L2_CACHE_HITS|V3D_PERF_COUNT_VPM_CYCLES_STALLED_VDW</tt>
      then you will receive exactly 3 values: <tt>V3D_PERF_COUNT_QPU_INSTRUCTION_CACHE_HITS</tt> in <tt>counters[0], </tt><tt>V3D_PERF_COUNT_VPM_CYCLES_STALLED_VDW</tt>
      in <tt>counters[1]</tt> and <tt>V3D_PERF_COUNT_L2C_L2_CACHE_HITS</tt> in <tt>counters[2]</tt>. Due to restrictions of
      VideoCore IV the call will <em>never return more than 16 values</em>.</p>
    <h2><a id="mmap" name="mmap"></a>Memory mapping</h2>
    <p>To be able to access the QPU memory from the ARM cortex you will need map the memory into you physical address space. Simply
      use <tt>mmap</tt> with the vcio2 device handle for this purpose.</p>
    <pre>unsigned offset = base &amp; 0xFFF;<br>char *mem = mmap(0, size + offset, PROT_READ|PROT_WRITE, MAP_SHARED, vcio2, base - offset);<br>if (mem != MAP_ERROR)<br>  mem += offset;</pre>
    <dl>
      <dt><tt>base</tt></dt>
      <dd>Physical address of the memory block from <a href="#IOCTL_MEM_LOCK"><tt>IOCTL_MEM_LOCK</tt></a>.<br>
        Note that <tt>mmap</tt> requires base to be aligned at a pages boundary (4096 bytes). Therefore the bit mask.</dd>
      <dt><tt>size</tt></dt>
      <dd>Number of bytes to map. This should be the same than the size passed to <a href="#IOCTL_MEM_ALLOC"><tt>IOCTL_MEM_ALLOC</tt></a>.</dd>
      <dt>return value <tt>mem</tt></dt>
      <dd>Virtual address of the mapped memory or <tt>MAP_FAILED</tt> on error.</dd>
      <dt><tt>mem + offset</tt></dt>
      <dd>Virtual address of the GPU memory to be used by the ARM core.</dd>
    </dl>
    <p>If the GPU memory is allocated with at least 4k alignment the offset calculations could be dropped since <tt>offset</tt> is
      always zero.</p>
    <p>vcio2 validates the memory mappings. I.e. you can only map memory that has been previously allocated with the same device
      handle. Otherwise you get an <tt>EACCES</tt> error.</p>
    <var></var>
  </body>
</html>
